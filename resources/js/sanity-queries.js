// GROQ queries for front-end data fetching.

window.SANITY_QUERIES = {
  DATE_IDEAS: `*[_type == "date_ideas"] | order(name asc) {
    _id,
    name,
    "slug": slug.current,
    has_date_and_time,
    start_datetime,
    end_datetime,
    start_date,
    end_date,
    all_day,
    recurring,
    recurrence_frequency,
    recurrence_interval,
    recurrence_by_weekday,
    recurrence_monthly_mode,
    recurrence_by_monthday,
    recurrence_by_weekday_ordinal,
    recurrence_by_monthly_weekday,
    recurrence_end_date,
    location,
    link,
    link_text,
    short_description,
    long_description,
    display_overall,
    "imageUrl": image.asset->url
  }`,

  DATE_IDEA_BY_ID: `*[_type == "date_ideas" && (slug.current == $id || _id == $id)][0] {
    _id,
    name,
    "slug": slug.current,
    has_date_and_time,
    start_datetime,
    end_datetime,
    start_date,
    end_date,
    all_day,
    recurring,
    recurrence_frequency,
    recurrence_interval,
    recurrence_by_weekday,
    recurrence_monthly_mode,
    recurrence_by_monthday,
    recurrence_by_weekday_ordinal,
    recurrence_by_monthly_weekday,
    recurrence_end_date,
    location,
    link,
    link_text,
    short_description,
    long_description,
    display_overall,
    "imageUrl": image.asset->url
  }`,

  POPUPS: `*[_type == "pop-ups"] | order(coalesce(start_datetime, start_date) asc) {
    _id,
    name,
    "slug": slug.current,
    start_datetime,
    end_datetime,
    start_date,
    end_date,
    all_day,
    recurring,
    recurrence_frequency,
    recurrence_interval,
    recurrence_by_weekday,
    recurrence_monthly_mode,
    recurrence_by_monthday,
    recurrence_by_weekday_ordinal,
    recurrence_by_monthly_weekday,
    recurrence_end_date,
    location,
    link,
    link_text,
    short_description,
    long_description,
    display_overall,
    display_in_calendar,
    // For the pop-ups page: hide items whose end datetime has passed. For all-day events,
    // ISO YYYY-MM-DD strings sort correctly as plain strings, so lexicographic comparison
    // on the date portion is equivalent to chronological comparison. The event remains
    // visible on its end date and disappears the following day.
    "display_in_popups_page": select(
      defined(end_datetime) && end_datetime < now() => false,
      defined(end_date) && end_date < now()[0..9] => false,
      display_in_popups_page
    ),
    // For the carousel: hide items whose end datetime has passed, using the same ISO
    // date string comparison logic for all-day events as described above.
    "display_in_carousel": select(
      defined(end_datetime) && end_datetime < now() => false,
      defined(end_date) && end_date < now()[0..9] => false,
      display_in_carousel
    ),
    "imageUrl": image.asset->url
  }`,

  POPUP_BY_ID: `*[_type == "pop-ups" && (slug.current == $id || _id == $id)][0] {
    _id,
    name,
    "slug": slug.current,
    start_datetime,
    end_datetime,
    start_date,
    end_date,
    all_day,
    recurring,
    recurrence_frequency,
    recurrence_interval,
    recurrence_by_weekday,
    recurrence_monthly_mode,
    recurrence_by_monthday,
    recurrence_by_weekday_ordinal,
    recurrence_by_monthly_weekday,
    recurrence_end_date,
    location,
    link,
    link_text,
    short_description,
    long_description,
    display_overall,
    display_in_calendar,
    display_in_popups_page,
    display_in_carousel,
    "imageUrl": image.asset->url
  }`,

  FEATURED_POSTS: `*[_type == "featured_post" && display_overall == true] | order(_updatedAt desc) {
    _id,
    name,
    embed_url,
    caption,
    display_overall
  }`,
};
